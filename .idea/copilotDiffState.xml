<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/components/LoadingSpinner.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/components/LoadingSpinner.tsx" />
              <option name="originalContent" value="import { useEffect, useRef, useMemo, useState } from 'react';&#10;&#10;interface LoadingSpinnerProps {&#10;  exiting?: boolean; // when true, fade out&#10;  disableScroll?: boolean; // when true, lock scroll (use for home only)&#10;  videoPlaybackRate?: number; // playback rate to use for video&#10;  onComplete?: () =&gt; void; // called when the video finishes or errors&#10;  exitAnimation?: 'fade' | 'slide-up' | 'scale-down' | 'wipe-up';&#10;}&#10;&#10;export default function LoadingSpinner({&#10;  exiting = false,&#10;  disableScroll = true,&#10;  videoPlaybackRate = 1.5,&#10;  onComplete,&#10;  exitAnimation = 'slide-up',&#10;}: LoadingSpinnerProps) {&#10;  const videoRef = useRef&lt;HTMLVideoElement | null&gt;(null);&#10;  const [imageFade, setImageFade] = useState(false); // fade out bg image at 3500ms&#10;&#10;  useEffect(() =&gt; {&#10;    const t = setTimeout(() =&gt; setImageFade(true), 3500);&#10;    return () =&gt; clearTimeout(t);&#10;  }, []);&#10;&#10;  useEffect(() =&gt; {&#10;    if (!disableScroll) return;&#10;    // Prevent scrolling when spinner is active&#10;    const originalBody = document.body.style.overflow;&#10;    const originalDoc = document.documentElement.style.overflow;&#10;    document.body.style.overflow = 'hidden';&#10;    document.documentElement.style.overflow = 'hidden';&#10;&#10;    return () =&gt; {&#10;      // Restore scrolling when component unmounts&#10;      document.body.style.overflow = originalBody;&#10;      document.documentElement.style.overflow = originalDoc || 'auto';&#10;    };&#10;  }, [disableScroll]);&#10;&#10;  const handleLoadedData = () =&gt; {&#10;    const v = videoRef.current;&#10;    if (v) {&#10;      try {&#10;        v.playbackRate = videoPlaybackRate;&#10;        const playPromise = v.play();&#10;        if (playPromise &amp;&amp; typeof playPromise.then === 'function') {&#10;          playPromise.catch(() =&gt; {});&#10;        }&#10;      } catch {}&#10;    }&#10;  };&#10;&#10;  const handleEnded = () =&gt; {&#10;    if (onComplete) onComplete();&#10;  };&#10;&#10;  const handleError = () =&gt; {&#10;    // If video can't play, don't block the app&#10;    if (onComplete) onComplete();&#10;  };&#10;&#10;  const overlayClass = useMemo(() =&gt; {&#10;    const base = 'loading-overlay';&#10;    if (!exiting) return base;&#10;    switch (exitAnimation) {&#10;      case 'fade':&#10;        return base + ' exit-fade';&#10;      case 'slide-up':&#10;        return base + ' exit-slide-up';&#10;      case 'scale-down':&#10;        return base + ' exit-scale-down';&#10;      case 'wipe-up':&#10;        return base + ' exit-wipe-up';&#10;      default:&#10;        return base + ' exit-fade';&#10;    }&#10;  }, [exiting, exitAnimation]);&#10;&#10;  return (&#10;    &lt;div&#10;      className={overlayClass}&#10;      style={{&#10;        position: 'fixed',&#10;        inset: 0,&#10;        width: '100vw',&#10;        height: '100vh',&#10;        backgroundColor: '#FFFFFF',&#10;        display: 'flex',&#10;        alignItems: 'center',&#10;        justifyContent: 'center',&#10;        zIndex: 99999,&#10;        pointerEvents: 'auto',&#10;        overflow: 'hidden'&#10;      }}&#10;    &gt;&#10;      {/* Background image layer fades out to reveal white */}&#10;      &lt;div&#10;        aria-hidden&#10;        className={`absolute inset-0 transition-opacity duration-700 ease-out ${imageFade ? 'opacity-0' : 'opacity-100'}`}&#10;        style={{&#10;          backgroundImage: 'url(/spinner-bg.png)',&#10;          backgroundSize: 'cover',&#10;          backgroundPosition: 'center',&#10;          backgroundRepeat: 'no-repeat',&#10;          willChange: 'opacity',&#10;          pointerEvents: 'none'&#10;        }}&#10;      /&gt;&#10;      &lt;div className=&quot;relative flex flex-col items-center&quot;&gt;&#10;        {/* Milkshake animation video plays once at 1.5x speed (MP4 only) */}&#10;        &lt;div className=&quot;relative w-40 h-40 sm:w-44 sm:h-44 md:w-48 md:h-48 lg:w-56 lg:h-56 xl:w-64 xl:h-64&quot;&gt;&#10;          &lt;video&#10;            ref={videoRef}&#10;            onLoadedData={handleLoadedData}&#10;            onEnded={handleEnded}&#10;            onError={handleError}&#10;            muted&#10;            playsInline&#10;            autoPlay&#10;            style={{ width: '100%', height: '100%', objectFit: 'contain' }}&#10;          &gt;&#10;            &lt;source src=&quot;/spinner-milkshake.mp4&quot; type=&quot;video/mp4&quot; /&gt;&#10;          &lt;/video&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Loading text */}&#10;        &lt;div className=&quot;mt-6 text-center&quot;&gt;&#10;          &lt;p className=&quot;text-xl font-semibold text-[#2b91cb]&quot;&gt;&#10;            Preparing Your Milkshake...&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import { useEffect, useRef, useMemo, useState } from 'react';&#10;&#10;interface LoadingSpinnerProps {&#10;  exiting?: boolean; // when true, fade out&#10;  disableScroll?: boolean; // when true, lock scroll (use for home only)&#10;  videoPlaybackRate?: number; // playback rate to use for video&#10;  onComplete?: () =&gt; void; // called when the video finishes or errors&#10;  exitAnimation?: 'fade' | 'slide-up' | 'scale-down' | 'wipe-up';&#10;}&#10;&#10;export default function LoadingSpinner({&#10;  exiting = false,&#10;  disableScroll = true,&#10;  videoPlaybackRate = 1.5,&#10;  onComplete,&#10;  exitAnimation = 'slide-up',&#10;}: LoadingSpinnerProps) {&#10;  const videoRef = useRef&lt;HTMLVideoElement | null&gt;(null);&#10;  const [isDesktop, setIsDesktop] = useState(false);&#10;  const [bgWhite, setBgWhite] = useState(false);&#10;&#10;  // Detect desktop (lg and up ~ 1024px)&#10;  useEffect(() =&gt; {&#10;    if (typeof window === 'undefined') return;&#10;    const mql: MediaQueryList = window.matchMedia('(min-width: 1024px)');&#10;    const handler = (ev: MediaQueryListEvent) =&gt; setIsDesktop(ev.matches);&#10;&#10;    // Apply initial state&#10;    setIsDesktop(mql.matches);&#10;&#10;    if (typeof mql.addEventListener === 'function') {&#10;      mql.addEventListener('change', handler);&#10;      return () =&gt; mql.removeEventListener('change', handler);&#10;    }&#10;&#10;    // Fallback for older browsers (Safari)&#10;    const legacy = mql as MediaQueryList &amp; {&#10;      addListener?: (listener: (this: MediaQueryList, ev: MediaQueryListEvent) =&gt; void) =&gt; void;&#10;      removeListener?: (listener: (this: MediaQueryList, ev: MediaQueryListEvent) =&gt; void) =&gt; void;&#10;    };&#10;    if (typeof legacy.addListener === 'function') {&#10;      legacy.addListener(handler);&#10;      return () =&gt; {&#10;        if (typeof legacy.removeListener === 'function') legacy.removeListener(handler);&#10;      };&#10;    }&#10;&#10;    return;&#10;  }, []);&#10;&#10;  // Timed background color for desktop; mobile is white immediately&#10;  useEffect(() =&gt; {&#10;    let t: ReturnType&lt;typeof setTimeout&gt; | null = null;&#10;    if (isDesktop) {&#10;      setBgWhite(false); // start at #FBFBFB&#10;      t = setTimeout(() =&gt; setBgWhite(true), 3500);&#10;    } else {&#10;      setBgWhite(true); // mobile: pure white from start&#10;    }&#10;    return () =&gt; { if (t) clearTimeout(t); };&#10;  }, [isDesktop]);&#10;&#10;  useEffect(() =&gt; {&#10;    if (!disableScroll) return;&#10;    // Prevent scrolling when spinner is active&#10;    const originalBody = document.body.style.overflow;&#10;    const originalDoc = document.documentElement.style.overflow;&#10;    document.body.style.overflow = 'hidden';&#10;    document.documentElement.style.overflow = 'hidden';&#10;&#10;    return () =&gt; {&#10;      // Restore scrolling when component unmounts&#10;      document.body.style.overflow = originalBody;&#10;      document.documentElement.style.overflow = originalDoc || 'auto';&#10;    };&#10;  }, [disableScroll]);&#10;&#10;  const handleLoadedData = () =&gt; {&#10;    const v = videoRef.current;&#10;    if (v) {&#10;      try {&#10;        v.playbackRate = videoPlaybackRate;&#10;        const playPromise = v.play();&#10;        if (playPromise &amp;&amp; typeof playPromise.then === 'function') {&#10;          playPromise.catch(() =&gt; {});&#10;        }&#10;      } catch {}&#10;    }&#10;  };&#10;&#10;  const handleEnded = () =&gt; { if (onComplete) onComplete(); };&#10;  const handleError = () =&gt; { if (onComplete) onComplete(); };&#10;&#10;  const overlayClass = useMemo(() =&gt; {&#10;    const base = 'loading-overlay';&#10;    if (!exiting) return base;&#10;    switch (exitAnimation) {&#10;      case 'fade': return base + ' exit-fade';&#10;      case 'slide-up': return base + ' exit-slide-up';&#10;      case 'scale-down': return base + ' exit-scale-down';&#10;      case 'wipe-up': return base + ' exit-wipe-up';&#10;      default: return base + ' exit-fade';&#10;    }&#10;  }, [exiting, exitAnimation]);&#10;&#10;  return (&#10;    &lt;div&#10;      className={overlayClass}&#10;      style={{&#10;        position: 'fixed',&#10;        inset: 0,&#10;        width: '100vw',&#10;        height: '100vh',&#10;        backgroundColor: isDesktop ? (bgWhite ? '#FFFFFF' : '#FBFBFB') : '#FFFFFF',&#10;        display: 'flex',&#10;        alignItems: 'center',&#10;        justifyContent: 'center',&#10;        zIndex: 99999,&#10;        pointerEvents: 'auto',&#10;        overflow: 'hidden'&#10;      }}&#10;    &gt;&#10;      &lt;div className=&quot;relative flex flex-col items-center&quot;&gt;&#10;        {/* Milkshake animation video plays once at configured speed */}&#10;        &lt;div className=&quot;relative w-40 h-40 sm:w-44 sm:h-44 md:w-48 md:h-48 lg:w-56 lg:h-56 xl:w-64 xl:h-64&quot;&gt;&#10;          &lt;video&#10;            ref={videoRef}&#10;            onLoadedData={handleLoadedData}&#10;            onEnded={handleEnded}&#10;            onError={handleError}&#10;            muted&#10;            playsInline&#10;            autoPlay&#10;            style={{ width: '100%', height: '100%', objectFit: 'contain' }}&#10;          &gt;&#10;            &lt;source src=&quot;/spinner-milkshake.mp4&quot; type=&quot;video/mp4&quot; /&gt;&#10;          &lt;/video&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Loading text */}&#10;        &lt;div className=&quot;mt-6 text-center&quot;&gt;&#10;          &lt;p className=&quot;text-xl font-semibold text-[#2b91cb]&quot;&gt;Preparing Your Milkshake...&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>